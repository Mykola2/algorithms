###### Практична робота №8
## Top Movie Picks

### Мета роботи:
Розібратись з алгоритмом `k-nearest neighbours`, використати знання з попередніх робіт курсу для побудови комплексної програми для підбору рекомендацій фільмів для перегляду на основі вподобань інших користувачів

## Що будемо робити?
![](./../res/to_watch.png)

Рекомендаційні системи на сьогодні існують в будь-якому сервісі що пропонує відео чи аудіо контент. Spotify чи Apple Music пропонують плейлісти на основі попередньо прослуханих пісень, Netflix показує відсоток того, наскільки він вважає користувачу має сподобатись певний фільм, навіть гугл в пошуковій видачі рекомендує фільми на основі попередніх запитів та переглядів в YouTube та PlayStore.

Рекомендаційні системи в певній мірі є перехідною темою між світом "класичних" алгоритмів та машинного навчання, а алгоритм к-найближчих сусідів - одним із найпростіших для побудови класифікаторів.

В цій роботі ми побудуємо систему, що рекомендує наступний фільм для перегляду на основі попередніх оцінок та пошуку користувачів зі схожим смаком. 

Для цього ми візьмемо дані з відомого вам сайту Kaggle - а саме [базу даних оцінок фільмів](https://www.kaggle.com/datasets/samlearner/letterboxd-movie-ratings-data?select=movie_data.csv) користувачів сайту [Letterboxd](https://letterboxd.com/). Ця база зберігає в собі біля восьми тисяч юзерів, що виставили для 285 000 фільмів більше 11 мільйонів оцінок.


## Порядок виконання

##### Теоретична підготовка

Перш ніж починати роботу, прочитайте 10 розділ книги `Grokking algorithms`, де достатньо детально описана ідея алгоритму `K-nearest neighbours` з різними прикладами, в тому числі і рекомендаційної системи схожої на ту, що ми будемо будувати.

##### Аналіз датасету

Датасет складається з трьох великих таблиць, кожну з яких вам буде потрібно парсити та використовувати:
- `users_export.csv` - дані про юзерів сервісу. В таблиці наведені ідентифікатор, нікнейм та імʼя для 8139 юзерів, а також трохи додаткової інформації
- `movie_data.csv` - дані про фільми. Таблиця містить багато інформації про всі доступні на платформи фільми
- `ratings_export.csv` - звʼязок між юзерами та фільмами - інформація про оцінки, які було виставлено різними користувачами фільмам. В таблиці використовуються нікнейми користувачів та ідентифікатори фільмів з першої та другої таблиць.

Ви можете вручну зчитувати файли та розбирати їх за допомогою стандартних засобів C#, а можете використати зручну бібліотеку [CSVHelper](https://joshclose.github.io/CsvHelper/getting-started/).

##### Створення структури даних 

В нашій роботі ми оберемо певну підмножину фільмів замість всієї бази. В колонці `genres` таблиці `movie_data` описано масив жанрів (чи ключових слів) до якиз відноситься певний фільм, якщо порахувати кількість можливих жанрів та їх частоту, то вийде наступне:

| Жанр            | Кількість фільмів | 
|-----------------|-------------------|
| Drama           | 82903             |
| Comedy          | 55540             |
| Documentary     | 39575             |
| Thriller        | 22225             |
| Horror          | 21812             |
| Romance         | 21783             |
| Action          | 20464             |
| Animation       | 19789             |
| Crime           | 15114             |
| Music           | 12657             |
| Adventure       | 11052             |
| Family          | 11021             |
| Science Fiction | 10236             |
| Fantasy         | 9226              |
| Mystery         | 8328              |
| TV Movie        | 7943              |
| History         | 5593              |
| War             | 4793              |
| Western         | 4461              |

Крім того, у частини фільмів в цій графі стоїть порожній масив, `null`, різні технічні позначки або крапка - це реальні дані, і нажаль майже будь-який датасет не ідеальний і його потрібно попередньо обробляти перж ніж аналізувати.

Ми зменшимо для нашої системи кількість жанрів до 8 - оскільки у нас є всього 8000 юзерів, побудова точок у просторі розмірності 19 може призвести до нефективної структури даних.

Отже, прочитайте дані про фільми з таблиці та лишіть лише ті що відносяться до категорій:
1. Drama
2. Comedy
3. Action (сюди додайте також фільми жанру Adventure)
4. Romance
5. Fiction (Science Fiction + Fantasy)
6. Animation
7. Thriller
8. Documentary

##### Підготовка користувачів

Проаналізуйте таблиці користувачів та оцінок та для кожного користувача вирахуйте його позицію у 8-мірному просторі вподобань. Для цього візьміть всі оцінки виставлені фільмам певного жанру, та спробуйте перевеси їх в шкалу від 0 до 1, наскільки користувачеві подобається цей жанр.

Найпростіше це зробити просто знайшовши середнє його оцінок, але така сама система не буде надто ефективною. Декілька ідей як це можна зробити краще:
- Фільтрувати якщо користувач поставив менше певної кількості оцінок жанру. Якщо людина подивились один хоррор і поставила йому оцінку 10 то не факт що його можна вважати хардкорним фанатом.
- Нормалізувати оцінки - якщо користувач А поставив 5 фільмам оцінку 8 і жодної десятки, а користувач В поставив цим же фільмам десятки, то виглядає так що їх смаки дуже схожі.

##### Написання базової програми

Напишіть консольну програму, що приймає команду `rate` разом із назвою фільма та оцінку по десятибальній шкалі. Наприклад:
```
> rate Forrest Gump 9
You've rated a film 'Forrest Gump' (forrest-gump) as 9.0
```

В дужках виводьте ідентифікатор фільму. Якщо фільм не знаходится в вашій базі, то використайте свої напрацювання з 5 роботи та напишіть підсистему що рекомендує найбільш схожі фільми:
```
> rate Star Bars: Episode II Attack of the Clones 7
No such film found :( Closest candidates:
Star Wars: Episode II - Attack of the Clones
```

Після того як користувач оцінить певну кількість фільмів, програма повинна почати реагувати на команду `recommend`. Програма має знайти позицію коритсувача у просторі вподобань та знайти N найближчих до нього користувачів (N можете підібрати самостійно). Використайте такий підхід:
1. Знайти найближчих користувачів.
2. Серед переглянутих "сусідами" фільмів, що користувач не бачив спробувати обрати той, що відноситься до категорій, які найбльш подобається користувачу і який бачили та високо оцінили якогомога більше "сусідів".

Наприклад, користувач дивиться та оцінює фільми у жанрі наукової фантастики. Під час підрахунку виявляється що серед "сусідів" декілька людей дивились та високо оцінили фільм `The Martian`, який користувач не бачив, і тому він буде рекомендований

##### Режим Discovery

Зазвичай, рекомендаційні сервіси не чекають поки користуввач оцінить багато фільмів, але для початку роботи їм потрібні хоч якісь стартові дані. Тому після реєстрації користувач може отримати ряд питань у стилі "чи дивились ви фільм Х?", щоб виконати хоча б базову класифікацію користувача. Подумайте, за яким  принципом можна запропонувати користувачу 10 фільмів, щоб його відповіді були максимально корисними? Почніть з питань про найбільш рейтингові фільми різних жанрів за думкою користувачів сайту. Програма в підсумку повинна виглядати так:
```
> discovery
Have you seen 'Titanic'? Y/N
> Yes
How would you rate it?
> 10
have you seen 'The Avengers'? Y/N
> No
...
```

#### Додаткові бали

Оскільки це остання робота терму (та і курсу), ви можете продемонструвати накопленні знання та заробити більше балів:
- Реалізуйте для пошуку найближчих сусідів не простий перебір, а [Kd-tree ](https://en.wikipedia.org/wiki/K-d_tree). Доведено, що при розмірності простоору `k` Kd-дерево буде ефективним тільки якщо кількість вершин N значно більша за 2^k, В нашому випадку 8000 користувачів більші за 2^8 (256), хоча в реальному проекті вигода від використання дерева стане помітна тільки починаючи з більшої кількості користувачів. За це можна отримати _**+3 бали**_
- Поекспериментуйте з алгоритмами визначення позиції користувача у просторі вподобань, підобру рекомендацій на основі оцінок найближчих користувачів та режиму `discovery`. За цікаві та ефективні рішення (з точки зору вашого teaching assistant) ви можете отримати до +2 балів 

## Оцінювання

Максимальний бал - 8 (також до +5 додаткових):
- Парсинг бази даних та побудова простору користувачів - _2 бали_;
- Написання програми - _1.5 бали_;
- Виправлення помилок у назві фільмів - _0.5 бали_;
- Теоретичні питання - _2 бали_;
- Виконання додаткового практичного завдання при здачі - _2 бали_;
- Написання Kd-дерева - до _+3 балів_;
- Покращення алгоритмів - до _+2 балів_.
